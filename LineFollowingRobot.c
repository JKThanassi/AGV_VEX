#pragma config(Sensor, in1,    line3,          sensorNone)
#pragma config(Sensor, in2,    line2,          sensorLineFollower)
#pragma config(Sensor, in3,    line1,          sensorLineFollower)
#pragma config(Sensor, in4,    line0,          sensorLineFollower)
#pragma config(Sensor, in5,    lineNeg1,       sensorLineFollower)
#pragma config(Sensor, in6,    lineNeg2,       sensorLineFollower)
#pragma config(Sensor, in7,    lineNeg3,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  ultra,          sensorSONAR_inch)
#pragma config(Motor,  port2,           motorDrive,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorSteer,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           illuminator,   tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//globals cause why not
int P;
float I;
float D;
int prevError;
float prevPID;

/**
@param sensorPos the value of the sensor currently above the line
@param desiredPos the sensor that you want to be above the line
*/
float calcCorrection(int sensorPos,int desiredPos){
	const float kP = 25,kI = .2,kD = 100;
	float PID;
	if(sensorPos <= 3){
		int error = desiredPos-sensorPos;
		P = error * kP;
		I += error;
		I *=kI;
		D = (error - prevError)*kD;
		prevError = error;
		PID = (P+I+D);
		prevPID = PID;
		return PID;
	}
	else if(sensorPos == 7){
		return 0;
	}
	else{
		return prevPID;
	}
}



//this function returns the value of the sensor currently above the black line
int getSensorPos(){
	const int threshold = 1800;
	//this statement checks if the sensor array has encountered a horizontal black line
	if (SensorValue[lineNeg3] > threshold
		&& SensorValue[lineNeg2] > threshold
	&& SensorValue[lineNeg1] > threshold
	&& SensorValue[line0] > threshold
	&& SensorValue[line1] > threshold
	&& SensorValue[line2] > threshold
	&& SensorValue[line3] > threshold) {
		return 7;
	}
	if(SensorValue[line3] > threshold){
		return 3;
	}
	if(SensorValue[line2] > threshold){
		return 2;
	}
	if(SensorValue[line1] > threshold){
		return 1;
	}
	if(SensorValue[line0] > threshold){
		return 0;
	}
	if(SensorValue[lineNeg1] > threshold){
		return -1;
	}
	if(SensorValue[lineNeg2] > threshold){
		return -2;
	}
	if(SensorValue[lineNeg3] > threshold){
		return -3;
	}

	//returns 9 when none of the sensors are above the line
	else{
		return 9;
	}

}



task main(){
	P=0;
	I=0;
	D=0;
	prevError=0;
	prevPID = 0;
	//set to false if you want to bypass driver control and go straight to autonomus
	//generally good for debugging and if you want to hook directly to the computer
	bool isDriverActive = false;
	int sensorPos = 0;
	int ultraVal;
	motor[illuminator] = 0;
	int frontMotorSpeed = 60, rearMotorSpeed = 0;
	while(isDriverActive){
		motor[motorDrive] = vexRT[Ch2];
		motor[motorSteer] = vexRT[Ch1];
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDCenteredString(0,"Front Rear");
		displayLCDNumber(1,3,motor[motorDrive]);
		//displayLCDString(1,0,"Rear");
		displayLCDNumber(1,6,motor[motorSteer]);


		if(vexRT[Btn6U] == 1){
			isDriverActive = false;
			wait1Msec(1000);
		}

	}


	while(!isDriverActive){
		sensorPos = getSensorPos();
		ultraVal = SensorValue[ultra];
		rearMotorSpeed=calcCorrection(sensorPos, 0);
		motor[motorSteer] = 0 + rearMotorSpeed;

		if(ultraVal < 17){
			if(ultraVal <= 13){
				motor[motorDrive]=0;
				motor[motorSteer]=0;
			}
			else{
				motor[motorDrive] = 15;
			}
		}
		else if(sensorPos == 9){
			motor[motorDrive] = frontMotorSpeed*.75;
			motor[motorSteer] = 0 + (rearMotorSpeed);
		}
		else if(sensorPos == 7 && prevPID<28){
			motor[motorSteer] = 0;
			motor[motorDrive] = 0;
			wait1Msec(3000);
		}

		else{
			motor[motorSteer] = 0 + rearMotorSpeed;
			motor[motorDrive] = frontMotorSpeed;
		}
		if(vexRT[Btn6U] == 1){
			isDriverActive = false;
		}
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0,0,"P:");
		displayLCDNumber(0,2,P);
		displayLCDString(0,7,"I:");
		displayLCDNumber(0,9,I);
		displayLCDString(0,11,"D:");
		displayLCDNumber(0,13,D);
		displayLCDString(1,0,"v:");
		displayLCDNumber(1,2,nAvgBatteryLevel,4);

		wait1Msec(5);
	}

}
